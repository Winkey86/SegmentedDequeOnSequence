Сделать отдельный класс 
SegmentedDeque :public ListSequence{
	private:
	ListSequence<ArraySequence<T>> *data;
}

1.Дек с сегментированным буфером

2.Типы хранимых элементов 
Элементы:
	Целые числа
	Вещественные числа
	Комплексные числа
	Строки
	Функции2)
	Персоны

2) Точнее, указатели на функции. Ниже – минимальный пример, как создать «список функций»:
	const int array_length = 3;
	int(**f)(int) = malloc(array_length * sizeof(int(*)(int)));
	f[0] = &inc1;
	f[1] = &inc2;
	f[2] = &inc3;
	for (int index = 0; index < length; index++)
		printf(“%i “, f[index](0));
	// Вывод: 1 2 3
3) Точнее, описывающие их структуры. Персона характеризуется набором атрибутов, таких ФИО, дата рождения, некоторый идентификатор (в роли которого может выступать: номер в некотором списке, номер зачетки/табельный номер, номер паспорта, и др.). Пример структуры, описывающей персону:
	class Person {
	private:
		PersonID id;
		char* firstName;
		char* middleName;
		char* lastName;
		time_t  erson te;
	public:
		PersonID GetID();
		char* GetFirstName();

	}
Тип PersonID предназначен для идентификации персоны и может быть объявлен различным образом, в зависимости от выбранного способа идентификации человека. Если для этих целей используется, скажем, номер паспорта, можно предложить, по крайней мере, два различных определения:
	первое:
	#typedef Person_ID char* // null-terminated string  вида “0982 123243”
	второе:
	#typedef Person_ID struct { // можно и в виде класса
		int series;  	// как вариант, char*
		int number; 	// как вариант, char*
	}
Для получения значения атрибутов предусматривают соответствующие методы, например:
	char* name = person->getName(); //  = “Иван”
	char* fullName = person->getFullName(); // = “Иван Иванович Иванов”, вычислимый атрибут


4. доп операции 
	Сортировка
	map1), where, reduce1)
	Конкатенация
	Извлечение подпоследовательности (по заданным индексам)
	Поиск на вхождение подпоследовательности

1) Если l=[a_1,..,a_n] – некоторый список элементов типа T, а f:T→T, то:
map(f,l)↦[f(a_1 ),..,f(a_n )]
Если, при тех же соглашениях, h:T→Bool – некоторая функция, возвращающая булево значение, то результатом where(h,l) будет новый список l', такой что: a_i^'∈l^'⇔h(a_i^' )=true. Т.е. where фильтрует значения из списка l с помощью функции-фильтра h.
Функция reduce работает несколько иначе: «сворачивает» список в одно значение по заданному правилу f:T×T→T:
reduce(f,l,c)↦f(a_n,(f(a_(n-1),(…f(a_2,(f(a_1 c)))))))
где c – константа, «стартовое» значение. Например, l=[1,2,3], f(x_1,x_2 )=2x_1+3x_2, тогда:
reduce(f,[1,2,3],4)=f(3,f(2,f(1,4)))=
=2⋅3+3(2⋅2+3(2⋅1+3⋅4))=
=2⋅3+3(2⋅2+3⋅14)=2⋅3+3⋅42=132  

